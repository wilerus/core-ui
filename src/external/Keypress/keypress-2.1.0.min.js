/*
  Keypress version 2.1.0 (c) 2014 David Mauro.
  Licensed under the Apache License, Version 2.0
  http://www.apache.org/licenses/LICENSE-2.0
*/
(function() {
    let m,
        v,
        y,
        z,
        A,
        r,
        w,
        B,
        F,
        C,
        G,
        H,
        p,
        s,
        q,
        o,
        t,
        D,
        I,
        E = {}.hasOwnProperty,
        j = [].indexOf || function(a) { for (let c = 0, b = this.length; c < b; c++) if (c in this && this[c] === a) return c; return -1; }; r = { is_unordered: !1, is_counting: !1, is_exclusive: !1, is_solitary: !1, prevent_default: !1, prevent_repeat: !1 }; D = 'meta alt option ctrl shift cmd'.split(' '); o = 'ctrl'; m = { debug: !1 }; const x = function(a) {
        let c,
            b; for (c in a)E.call(a, c) && (b = a[c], !1 !== b && (this[c] = b)); this.keys = this.keys || []; this.count = this.count || 0;
    }; x.prototype.allows_key_repeat =
function() { return !this.prevent_repeat && typeof this.on_keydown === 'function'; }; x.prototype.reset = function() { this.count = 0; return this.keyup_fired = null; }; const g = function(a, c) {
        let b,
            d; this.should_force_event_defaults = this.should_suppress_event_defaults = !1; this.sequence_delay = 800; this._registered_combos = []; this._keys_down = []; this._active_combos = []; this._sequence = []; this._sequence_timer = null; this._prevent_capture = !1; this._defaults = c || {}; for (b in r)E.call(r, b) && (d = r[b], this._defaults[b] = this._defaults[b] || d);
        this.element = a || document.body; b = function(a, b, c) { a.addEventListener ? a.addEventListener(b, c) : a.attachEvent && a.attachEvent(`on${b}`, c); return c; }; const e = this; this.keydown_event = b(this.element, 'keydown', (a) => { a = a || window.event; e._receive_input(a, !0); return e._bug_catcher(a); }); const f = this; this.keyup_event = b(this.element, 'keyup', (a) => { a = a || window.event; return f._receive_input(a, !1); }); const h = this; this.blur_event = b(window, 'blur', () => {
            let a,
                b,
                c,
                d; d = h._keys_down; b = 0; for (c = d.length; b < c; b++) {
                a = d[b],
                h._key_up(a, {});
            } return h._keys_down = [];
        });
    }; g.prototype.destroy = function() { let a; a = function(a, b, d) { if (a.removeEventListener != null) return a.removeEventListener(b, d); if (a.removeEvent != null) return a.removeEvent(`on${b}`, d); }; a(this.element, 'keydown', this.keydown_event); a(this.element, 'keyup', this.keyup_event); return a(window, 'blur', this.blur_event); }; g.prototype._bug_catcher = function(a) {
        let c; if (o === 'cmd' && j.call(this._keys_down, 'cmd') >= 0 && (c = z(a.keyCode)) !== 'cmd' && c !== 'shift' && c !== 'alt' && c !== 'caps' && c !==
'tab') return this._receive_input(a, !1);
    }; g.prototype._cmd_bug_check = function(a) { return o === 'cmd' && j.call(this._keys_down, 'cmd') >= 0 && j.call(a, 'cmd') < 0 ? !1 : !0; }; g.prototype._prevent_default = function(a, c) { if ((c || this.should_suppress_event_defaults) && !this.should_force_event_defaults) if (a.preventDefault ? a.preventDefault() : a.returnValue = !1, a.stopPropagation) return a.stopPropagation(); }; g.prototype._get_active_combos = function(a) {
        let c,
            b; c = []; b = w(this._keys_down, (b) => b !== a); b.push(a); this._match_combo_arrays(b,
            (function(a) { return function(b) { if (a._cmd_bug_check(b.keys)) return c.push(b); }; }(this))); this._fuzzy_match_combo_arrays(b, (function(a) { return function(b) { if (!(j.call(c, b) >= 0) && !b.is_solitary && a._cmd_bug_check(b.keys)) return c.push(b); }; }(this))); return c;
    }; g.prototype._get_potential_combos = function(a) {
        let c,
            b,
            d,
            e,
            f; b = []; f = this._registered_combos; d = 0; for (e = f.length; d < e; d++)c = f[d], c.is_sequence || j.call(c.keys, a) >= 0 && this._cmd_bug_check(c.keys) && b.push(c); return b;
    }; g.prototype._add_to_active_combos = function(a) {
        let c,
            b,
            d,
            e,
            f,
            h,
            i,
            g,
            n,
            k,
            l; h = !1; f = !0; d = !1; if (j.call(this._active_combos, a) >= 0) return !0; if (this._active_combos.length) {
            e = i = 0; for (k = this._active_combos.length; k >= 0 ? i < k : i > k; e = k >= 0 ? ++i : --i) {
                if ((c = this._active_combos[e]) && c.is_exclusive && a.is_exclusive) {
                    c = c.keys; if (!h) { g = 0; for (n = c.length; g < n; g++) if (b = c[g], h = !0, j.call(a.keys, b) < 0) { h = !1; break; } } if (f && !h) { l = a.keys; g = 0; for (n = l.length; g < n; g++) if (b = l[g], f = !1, j.call(c, b) < 0) { f = !0; break; } }h && (d ? (c = this._active_combos.splice(e, 1)[0], c != null && c.reset()) : (c = this._active_combos.splice(e,
                        1, a)[0], c != null && c.reset(), d = !0), f = !1);
                }
            }
        }f && this._active_combos.unshift(a); return h || f;
    }; g.prototype._remove_from_active_combos = function(a) {
        let c,
            b,
            d,
            e; b = d = 0; for (e = this._active_combos.length; e >= 0 ? d < e : d > e; b = e >= 0 ? ++d : --d) if (c = this._active_combos[b], c === a) { a = this._active_combos.splice(b, 1)[0]; a.reset(); break; }
    }; g.prototype._get_possible_sequences = function() {
        let a,
            c,
            b,
            d,
            e,
            f,
            h,
            i,
            g,
            n,
            k,
            l; d = []; n = this._registered_combos; f = 0; for (g = n.length; f < g; f++) {
            a = n[f]; c = h = 1; for (k = this._sequence.length; k >= 1 ? h <= k : h >= k; c = k >=
1 ? ++h : --h) if (e = this._sequence.slice(-c), a.is_sequence) { if (j.call(a.keys, 'shift') < 0 && (e = w(e, (a) => a !== 'shift'), !e.length)) continue; c = i = 0; for (l = e.length; l >= 0 ? i < l : i > l; c = l >= 0 ? ++i : --i) if (a.keys[c] === e[c])b = !0; else { b = !1; break; }b && d.push(a); }
        } return d;
    }; g.prototype._add_key_to_sequence = function(a, c) {
        let b,
            d,
            e,
            f; this._sequence.push(a); d = this._get_possible_sequences(); if (d.length) {
            e = 0; for (f = d.length; e < f; e++)b = d[e], this._prevent_default(c, b.prevent_default); this._sequence_timer && clearTimeout(this._sequence_timer);
            this.sequence_delay > -1 && (this._sequence_timer = setTimeout(function() { return this._sequence = []; }, this.sequence_delay));
        } else this._sequence = [];
    }; g.prototype._get_sequence = function(a) {
        let c,
            b,
            d,
            e,
            f,
            h,
            i,
            g,
            n,
            k,
            l,
            u; k = this._registered_combos; h = 0; for (n = k.length; h < n; h++) {
            if (c = k[h], c.is_sequence) {
                b = i = 1; for (l = this._sequence.length; l >= 1 ? i <= l : i >= l; b = l >= 1 ? ++i : --i) {
                    if (f = w(this._sequence, (a) => (j.call(c.keys, 'shift') >= 0 ? !0 : a !== 'shift')).slice(-b), c.keys.length === f.length) {
                        b = g = 0; for (u = f.length; u >= 0 ? g < u : g > u; b =
u >= 0 ? ++g : --g) if (e = f[b], !(j.call(c.keys, 'shift') < 0 && e === 'shift') && !(a === 'shift' && j.call(c.keys, 'shift') < 0)) if (c.keys[b] === e)d = !0; else { d = !1; break; }
                    }
                } if (d) return c;
            }
        } return !1;
    }; g.prototype._receive_input = function(a, c) { let b; if (this._prevent_capture) this._keys_down.length && (this._keys_down = []); else if (b = z(a.keyCode), (c || this._keys_down.length || !(b === 'alt' || b === o)) && b) return c ? this._key_down(b, a) : this._key_up(b, a); }; g.prototype._fire = function(a, c, b, d) {
        typeof c[`on_${a}`] === 'function' && this._prevent_default(b,
            !0 !== c[`on_${a}`].call(c.this, b, c.count, d)); a === 'release' && (c.count = 0); if (a === 'keyup') return c.keyup_fired = !0;
    }; g.prototype._match_combo_arrays = function(a, c) {
        let b,
            d,
            e,
            f; f = this._registered_combos; d = 0; for (e = f.length; d < e; d++)b = f[d], (!b.is_unordered && y(a, b.keys) || b.is_unordered && v(a, b.keys)) && c(b);
    }; g.prototype._fuzzy_match_combo_arrays = function(a, c) {
        let b,
            d,
            e,
            f; f = this._registered_combos; d = 0; for (e = f.length; d < e; d++)b = f[d], (!b.is_unordered && C(b.keys, a) || b.is_unordered && F(b.keys, a)) && c(b);
    }; g.prototype._keys_remain =
function(a) {
    let c,
        b,
        d,
        e; e = a.keys; b = 0; for (d = e.length; b < d; b++) if (a = e[b], j.call(this._keys_down, a) >= 0) { c = !0; break; } return c;
}; g.prototype._key_down = function(a, c) {
        let b,
            d,
            e,
            f,
            h; (b = A(a, c)) && (a = b); this._add_key_to_sequence(a, c); (b = this._get_sequence(a)) && this._fire('keydown', b, c); for (e in t)b = t[e], c[b] && (e === a || j.call(this._keys_down, e) >= 0 || this._keys_down.push(e)); for (e in t) {
            if (b = t[e], e !== a && j.call(this._keys_down, e) >= 0 && !c[b] && !(e === 'cmd' && o !== 'cmd')) {
                b = d = 0; for (f = this._keys_down.length; f >= 0 ? d < f : d > f; b = f >=
0 ? ++d : --d) this._keys_down[b] === e && this._keys_down.splice(b, 1);
            }
        }d = this._get_active_combos(a); e = this._get_potential_combos(a); f = 0; for (h = d.length; f < h; f++)b = d[f], this._handle_combo_down(b, e, a, c); if (e.length) { d = 0; for (f = e.length; d < f; d++)b = e[d], this._prevent_default(c, b.prevent_default); }j.call(this._keys_down, a) < 0 && this._keys_down.push(a);
    }; g.prototype._handle_combo_down = function(a, c, b, d) {
        let e,
            f,
            h,
            g,
            m; if (j.call(a.keys, b) < 0) return !1; this._prevent_default(d, a && a.prevent_default); e = !1; if (j.call(this._keys_down,
            b) >= 0 && (e = !0, !a.allows_key_repeat())) return !1; h = this._add_to_active_combos(a, b); b = a.keyup_fired = !1; if (a.is_exclusive) { g = 0; for (m = c.length; g < m; g++) if (f = c[g], f.is_exclusive && f.keys.length > a.keys.length) { b = !0; break; } } if (!b && (a.is_counting && typeof a.on_keydown === 'function' && (a.count += 1), h)) return this._fire('keydown', a, d, e);
    }; g.prototype._key_up = function(a, c) {
        let b,
            d,
            e,
            f,
            h,
            g; b = a; (e = A(a, c)) && (a = e); e = s[b]; c.shiftKey ? e && j.call(this._keys_down, e) >= 0 || (a = b) : b && j.call(this._keys_down, b) >= 0 || (a = e); (f = this._get_sequence(a)) &&
this._fire('keyup', f, c); if (j.call(this._keys_down, a) < 0) return !1; f = h = 0; for (g = this._keys_down.length; g >= 0 ? h < g : h > g; f = g >= 0 ? ++h : --h) if ((d = this._keys_down[f]) === a || d === e || d === b) { this._keys_down.splice(f, 1); break; }d = this._active_combos.length; e = []; g = this._active_combos; f = 0; for (h = g.length; f < h; f++)b = g[f], j.call(b.keys, a) >= 0 && e.push(b); f = 0; for (h = e.length; f < h; f++)b = e[f], this._handle_combo_up(b, c, a); if (d > 1) {
            h = this._active_combos; d = 0; for (f = h.length; d < f; d++) {
                b = h[d], void 0 === b || j.call(e, b) >= 0 || this._keys_remain(b) ||
this._remove_from_active_combos(b);
            }
        }
    }; g.prototype._handle_combo_up = function(a, c, b) {
        let d,
            e; this._prevent_default(c, a && a.prevent_default); e = this._keys_remain(a); if (!a.keyup_fired && (d = this._keys_down.slice(), d.push(b), !a.is_solitary || v(d, a.keys))) this._fire('keyup', a, c), a.is_counting && (typeof a.on_keyup === 'function' && typeof a.on_keydown !== 'function') && (a.count += 1); e || (this._fire('release', a, c), this._remove_from_active_combos(a));
    }; g.prototype.simple_combo = function(a, c) {
        return this.register_combo({ keys: a,
            on_keydown: c });
    }; g.prototype.counting_combo = function(a, c) { return this.register_combo({ keys: a, is_counting: !0, is_unordered: !1, on_keydown: c }); }; g.prototype.sequence_combo = function(a, c) { return this.register_combo({ keys: a, on_keydown: c, is_sequence: !0 }); }; g.prototype.register_combo = function(a) {
        let c,
            b,
            d; typeof a.keys === 'string' && (a.keys = a.keys.split(' ')); d = this._defaults; for (c in d)E.call(d, c) && (b = d[c], void 0 === a[c] && (a[c] = b)); a = new x(a); if (I(a)) return this._registered_combos.push(a), a;
    }; g.prototype.register_many =
function(a) {
    let c,
        b,
        d,
        e; e = []; b = 0; for (d = a.length; b < d; b++)c = a[b], e.push(this.register_combo(c)); return e;
}; g.prototype.unregister_combo = function(a) {
        let c,
            b,
            d,
            e,
            f,
            g; if (!a) return !1; const i = this; b = function(a) {
            let b,
                c,
                d,
                e; e = []; b = c = 0; for (d = i._registered_combos.length; d >= 0 ? c < d : c > d; b = d >= 0 ? ++c : --c) if (a === i._registered_combos[b]) { i._registered_combos.splice(b, 1); break; } else e.push(void 0); return e;
        }; if (a instanceof x) return b(a); typeof a === 'string' && (a = a.split(' ')); f = this._registered_combos; g = []; d = 0; for (e = f.length; d <
e; d++)c = f[d], c != null && (c.is_unordered && v(a, c.keys) || !c.is_unordered && y(a, c.keys) ? g.push(b(c)) : g.push(void 0)); return g;
    }; g.prototype.unregister_many = function(a) {
        let c,
            b,
            d,
            e; e = []; b = 0; for (d = a.length; b < d; b++)c = a[b], e.push(this.unregister_combo(c)); return e;
    }; g.prototype.get_registered_combos = function() { return this._registered_combos; }; g.prototype.reset = function() { return this._registered_combos = []; }; g.prototype.listen = function() { return this._prevent_capture = !1; }; g.prototype.stop_listening = function() {
        return this._prevent_capture =
!0;
    }; g.prototype.get_meta_key = function() { return o; }; m.Listener = g; z = function(a) { return p[a]; }; w = function(a, c) {
        let b; if (a.filter) return a.filter(c); let d,
            e,
            f; f = []; d = 0; for (e = a.length; d < e; d++)b = a[d], c(b) && f.push(b); return f;
    }; v = function(a, c) {
        let b,
            d,
            e; if (a.length !== c.length) return !1; d = 0; for (e = a.length; d < e; d++) if (b = a[d], !(j.call(c, b) >= 0)) return !1; return !0;
    }; y = function(a, c) {
        let b,
            d,
            e; if (a.length !== c.length) return !1; b = d = 0; for (e = a.length; e >= 0 ? d < e : d > e; b = e >= 0 ? ++d : --d) if (a[b] !== c[b]) return !1; return !0;
    }; F = function(a,
        c) {
        let b,
            d,
            e; d = 0; for (e = a.length; d < e; d++) if (b = a[d], j.call(c, b) < 0) return !1; return !0;
    }; B = Array.prototype.indexOf || function(a, c) {
        let b,
            d,
            e; b = d = 0; for (e = a.length; e >= 0 ? d <= e : d >= e; b = e >= 0 ? ++d : --d) if (a[b] === c) return b; return -1;
    }; C = function(a, c) {
        let b,
            d,
            e,
            f; e = d = 0; for (f = a.length; e < f; e++) if (b = a[e], b = B.call(c, b), b >= d)d = b; else return !1; return !0;
    }; q = function() { if (m.debug) return console.log.apply(console, arguments); }; G = function(a) {
        let c,
            b,
            d; c = !1; for (d in p) if (b = p[d], a === b) { c = !0; break; } if (!c) {
            for (d in s) {
                if (b = s[d], a === b) {
                    c =
!0; break;
                }
            }
        } return c;
    }; I = function(a) {
        let c,
            b,
            d,
            e,
            f,
            g,
            i; f = !0; a.keys.length || q("You're trying to bind a combo with no keys:", a); b = g = 0; for (i = a.keys.length; i >= 0 ? g < i : g > i; b = i >= 0 ? ++g : --g)d = a.keys[b], (c = H[d]) && (d = a.keys[b] = c), d === 'meta' && a.keys.splice(b, 1, o), d === 'cmd' && q('Warning: use the "meta" key rather than "cmd" for Windows compatibility'); i = a.keys; c = 0; for (g = i.length; c < g; c++)d = i[c], G(d) || (q(`Do not recognize the key "${d}"`), f = !1); if (j.call(a.keys, 'meta') >= 0 || j.call(a.keys, 'cmd') >= 0) {
            c = a.keys.slice(); g =
0; for (i = D.length; g < i; g++)d = D[g], (b = B.call(c, d)) > -1 && c.splice(b, 1); c.length > 1 && (q('META and CMD key combos cannot have more than 1 non-modifier keys', a, c), f = !1);
        } for (e in a)r[e] === 'undefined' && q(`The property ${e} is not a valid combo property. Your combo has still been registered.`); return f;
    }; A = function(a, c) { let b; if (!c.shiftKey) return !1; b = s[a]; return b != null ? b : !1; }; t = { cmd: 'metaKey', ctrl: 'ctrlKey', shift: 'shiftKey', alt: 'altKey' }; H = { escape: 'esc',
        control: 'ctrl',
        command: 'cmd',
        break: 'pause',
        windows: 'cmd',
        option: 'alt',
        caps_lock: 'caps',
        apostrophe: "'",
        semicolon: ';',
        tilde: '~',
        accent: '`',
        scroll_lock: 'scroll',
        num_lock: 'num' }; s = { '/': '?', '.': '>', ',': '<', "'": '"', ';': ':', '[': '{', ']': '}', '\\': '|', '`': '~', '=': '+', '-': '_', 1: '!', 2: '@', 3: '#', 4: '$', 5: '%', 6: '^', 7: '&', 8: '*', 9: '(', 0: ')' }; p = { 0: '\\',
        8: 'backspace',
        9: 'tab',
        12: 'num',
        13: 'enter',
        16: 'shift',
        17: 'ctrl',
        18: 'alt',
        19: 'pause',
        20: 'caps',
        27: 'esc',
        32: 'space',
        33: 'pageup',
        34: 'pagedown',
        35: 'end',
        36: 'home',
        37: 'left',
        38: 'up',
        39: 'right',
        40: 'down',
        44: 'print',
        45: 'insert',
        46: 'delete',
        48: '0',
        49: '1',
        50: '2',
        51: '3',
        52: '4',
        53: '5',
        54: '6',
        55: '7',
        56: '8',
        57: '9',
        65: 'a',
        66: 'b',
        67: 'c',
        68: 'd',
        69: 'e',
        70: 'f',
        71: 'g',
        72: 'h',
        73: 'i',
        74: 'j',
        75: 'k',
        76: 'l',
        77: 'm',
        78: 'n',
        79: 'o',
        80: 'p',
        81: 'q',
        82: 'r',
        83: 's',
        84: 't',
        85: 'u',
        86: 'v',
        87: 'w',
        88: 'x',
        89: 'y',
        90: 'z',
        91: 'cmd',
        92: 'cmd',
        93: 'cmd',
        96: 'num_0',
        97: 'num_1',
        98: 'num_2',
        99: 'num_3',
        100: 'num_4',
        101: 'num_5',
        102: 'num_6',
        103: 'num_7',
        104: 'num_8',
        105: 'num_9',
        106: 'num_multiply',
        107: 'num_add',
        108: 'num_enter',
        109: 'num_subtract',
        110: 'num_decimal',
        111: 'num_divide',
        112: 'f1',
        113: 'f2',
        114: 'f3',
        115: 'f4',
        116: 'f5',
        117: 'f6',
        118: 'f7',
        119: 'f8',
        120: 'f9',
        121: 'f10',
        122: 'f11',
        123: 'f12',
        124: 'print',
        144: 'num',
        145: 'scroll',
        186: ';',
        187: '=',
        188: ',',
        189: '-',
        190: '.',
        191: '/',
        192: '`',
        219: '[',
        220: '\\',
        221: ']',
        222: "'",
        223: '`',
        224: 'cmd',
        225: 'alt',
        57392: 'ctrl',
        63289: 'num',
        59: ';',
        61: '-',
        173: '=' }; m._keycode_dictionary = p; m._is_array_in_array_sorted = C; navigator.userAgent.indexOf('Mac OS X') !== -1 && (o = 'cmd'); navigator.userAgent.indexOf('Opera') !== -1 && (p['17'] = 'cmd'); typeof define === 'function' &&
define.amd ? define([], () => m) : typeof exports !== 'undefined' && exports !== null ? exports.keypress = m : window.keypress = m;
}).call(this);
